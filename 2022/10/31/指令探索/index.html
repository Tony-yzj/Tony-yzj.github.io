<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>指令探索 | Tech, Poem &amp; More</title><meta name="keywords" content="Intel汇编指令 汇编与接口"><meta name="author" content="也无风雨"><meta name="copyright" content="也无风雨"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="ZJU《汇编与接口》课程探索实验Ⅰ">
<meta property="og:type" content="article">
<meta property="og:title" content="指令探索">
<meta property="og:url" content="http://tony-yzj.cn/2022/10/31/%E6%8C%87%E4%BB%A4%E6%8E%A2%E7%B4%A2/index.html">
<meta property="og:site_name" content="Tech, Poem &amp; More">
<meta property="og:description" content="ZJU《汇编与接口》课程探索实验Ⅰ">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s2.loli.net/2023/02/02/LI1QZmy5l2TqzeY.jpg">
<meta property="article:published_time" content="2022-10-31T09:05:00.000Z">
<meta property="article:modified_time" content="2023-02-03T08:51:53.846Z">
<meta property="article:author" content="也无风雨">
<meta property="article:tag" content="ASM">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s2.loli.net/2023/02/02/LI1QZmy5l2TqzeY.jpg"><link rel="shortcut icon" href="/img/stars.png"><link rel="canonical" href="http://tony-yzj.cn/2022/10/31/%E6%8C%87%E4%BB%A4%E6%8E%A2%E7%B4%A2/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":5,"languages":{"author":"作者: 也无风雨","link":"链接: ","source":"来源: Tech, Poem & More","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '指令探索',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-02-03 16:51:53'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://s2.loli.net/2022/10/01/I2nSFvzp48lecKO.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">6</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">3</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://s2.loli.net/2023/02/02/LI1QZmy5l2TqzeY.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Tech, Poem &amp; More</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">指令探索</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-10-31T09:05:00.000Z" title="发表于 2022-10-31 17:05:00">2022-10-31</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-02-03T08:51:53.846Z" title="更新于 2023-02-03 16:51:53">2023-02-03</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/CS/">CS</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">6.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>20分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="指令探索"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="x86架构下A系列寄存器算数操作（以ADD指令为例）的提速情况探索"><a href="#x86架构下A系列寄存器算数操作（以ADD指令为例）的提速情况探索" class="headerlink" title="x86架构下A系列寄存器算数操作（以ADD指令为例）的提速情况探索"></a><center>x86架构下A系列寄存器算数操作（以ADD指令为例）的提速情况探索</center></h1><p>课程名称：汇编与接口</p>
<p>学生姓名：云中君</p>
<p>学号：********</p>
<p>邮件地址：********@zju.edu.cn</p>
<hr>
<h2 id="一、探索背景"><a href="#一、探索背景" class="headerlink" title="一、探索背景"></a>一、探索背景</h2><p>​	印象里是在学习数字逻辑时第一次听说累加器这样一个元件，但是在课上它并不是主角，记得当时老师只是随口一提，然后将大量的篇幅留给了复杂的带进位的加法器的实现，给人一种它没有很大应用场景或者使用效果并不理想的印象。所以当时也没有在意，直到后来在体系结构的课程上讲到了几种ISA class，其中包含了Accumulator类型，课上老师要求将一段简单的加法代码翻译成四种类型，在这个过程中，我发现它与RISC-V的load-store模式有很大的不同，甚至猜测在大量加法时感觉比起load-store可以提速不少，这也让我又一次注意到这个器件。</p>
<p>​	而在本门课的课堂上，在讲x86各个系列寄存器时，老师提到了A系列寄存器Accumulator Register，也就是累加器，它又一次出现在我面前。上课提到它会被自动分配给一些算数指令，也讲到了它的特殊性——<code>add eax, 0xffff7040</code>竟然比<code>add ebx, 0xffff7040</code>要快。老师的解释是编码上eax寄存器单独编码，比ebx短，因而更快，但是没有具体测试，只是参考了intel的手册。这也引起了我的兴趣，很好奇A系列寄存器作为累加器的作用，也想从这一点切入来进行探索，来探究其是否真的能够实现加速，以及指令编码更短是否确实对速度的提升有效果。</p>
<hr>
<h2 id="二、探索过程"><a href="#二、探索过程" class="headerlink" title="二、探索过程"></a>二、探索过程</h2><h3 id="1-基于time-h的简易测试程序"><a href="#1-基于time-h的简易测试程序" class="headerlink" title="1. 基于time.h的简易测试程序"></a>1. 基于time.h的简易测试程序</h3><p>​	因为此前没有接触过x86汇编的编写，我一时间不知道在什么平台运行汇编指令，以及怎么使用x86汇编指令进行计时。而对于记录程序运行时间，我们此前程序课程上用到最多的是方法是调用C语言的time.h库中的clock()函数，通过<code>程序运行时间=程序运行的时钟周期/每秒的时钟周期数</code>这一公式来实现比较精准的时间计算。</p>
<p>​	但是仅通过C语言来书写，显然不能够实现寄存器层面的绑定。使用C语言的加法，必然会分配到相同的寄存器用于处理。联系到操作系统课程中刚刚学习的内敛汇编相关知识，可以用于RISC-V的指令的执行，那应该也可以使用于x86指令，因此我编写了如下的第一段内联汇编，用以测试。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">asm</span>(</span><br><span class="line">           <span class="string">&quot;add eax, 0xffff7040&quot;</span></span><br><span class="line">           : :</span><br><span class="line">           : <span class="string">&quot;eax&quot;</span></span><br><span class="line">       );</span><br></pre></td></tr></table></figure>

<p>​	在运行时显示了如下错误，显示” too many memory references for add“，问题一定在于内联汇编不合规范。</p>
<p>![image-20221026215228395](D:\CS\2022 fall-winter\OS\指令探索\image-20221026215228395.png)</p>
<p>​	仔细了解了内联汇编的规范，发现内联汇编似乎支持的是AT&amp;T格式，与我们上课学习的intel格式不同。对于寄存器，需要加%前缀，而为了避免在汇编语句中%表示输入、输出操作数的混淆，需要加%%，而地址则需要加$前缀。这样修改后，仍然会出现错误，显示operand type mismatch for ‘add‘，进一步学习后发现，大多数该类的内联汇编代码实例都将立即数写于寄存器前，故修改如下，可以正常运行。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REPEAT 1000000000</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">clock_t</span> start, end;</span><br><span class="line">    <span class="comment">//bind registers eax/ebx with variables a/b</span></span><br><span class="line">    <span class="keyword">register</span> <span class="type">unsigned</span> <span class="type">int</span> a <span class="title function_">asm</span> <span class="params">(<span class="string">&quot;%eax&quot;</span>)</span>;</span><br><span class="line">    <span class="keyword">register</span> <span class="type">unsigned</span> <span class="type">int</span> b <span class="title function_">asm</span> <span class="params">(<span class="string">&quot;%ebx&quot;</span>)</span>;</span><br><span class="line"></span><br><span class="line">    start = clock();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">long</span> <span class="type">int</span> i=<span class="number">0</span>; i&lt;REPEAT; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">asm</span>(</span><br><span class="line">            <span class="string">&quot;add %%eax,$0xffff7040&quot;</span></span><br><span class="line">            : :</span><br><span class="line">            : </span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    end = clock();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;EAX: time is %f s\n&quot;</span>, (<span class="type">double</span>)(<span class="number">1.0</span>*(end-start)/CLOCKS_PER_SEC));</span><br><span class="line"></span><br><span class="line">    start = clock();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">long</span> <span class="type">int</span> i=<span class="number">0</span>; i&lt;REPEAT; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">asm</span>(</span><br><span class="line">            <span class="string">&quot;add $0xffff7040,%%ebx&quot;</span></span><br><span class="line">            : :</span><br><span class="line">            : </span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    end = clock();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;EBX: time is %f s\n&quot;</span>, (<span class="type">double</span>)(<span class="number">1.0</span>*(end-start)/CLOCKS_PER_SEC));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	使用gcc编译后，对其进行反汇编，查看该程序对应的x86汇编代码，可以看到对应指令就是需要测试的指令。</p>
<img src="image-20221027202448227.png" alt="image-20221027202448227" style="zoom:33%;" />

<img src="image-20221027202555201.png" alt="image-20221027202555201" style="zoom: 33%;" />

<p>​	在Linux Ubuntu环境下每条指令循环十亿次，获得基本的速度情况，确实发现就这一条ADD指令来说EAX要快于EBX，但是相对来说相差并不明显。</p>
<img src="image-20221027203920549.png" alt="image-20221027203920549" style="zoom: 33%;" />

<p>​	将EAX&#x2F;EBX的测试顺序交换，测试速度情况，以排除顺序的问题。</p>
<img src="image-20221027204440953.png" alt="image-20221027204440953" style="zoom:33%;" />

<p>​	但是发现似乎对于反向顺序的测试，结果刚好相反，而且即使我在不同时间段、不同电脑运行模式以及不同重复次数的测试下得到的结果也类似</p>
<p>​	下图为电脑静音模式下的结果。</p>
<img src="image-20221027210712388.png" alt="image-20221027210712388" style="zoom:33%;" />

<p>​	但是这样判断显然存在一些问题，也就是我仅仅执行了少数几次程序，对于结果比较明显（比如运行十次，每次都是eax快于ebx）的情况确实可以进行初步判断，但是对于一些结果有浮动的情况不能精确判断，那么仅仅运行10次并不具有参考意义。对此，我编写了一个shell脚本用于批量测试，实现运行多次程序，并求出结果的平均数（其中测试程序<code>test</code>输出<code>ebx运行周期数/eax运行周期数</code>）。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">re=0</span><br><span class="line">div=**** #the number of times for loop</span><br><span class="line">for ((i=0;i&lt;div;i++))</span><br><span class="line">do</span><br><span class="line">    a=`./$1`	#for specific test program</span><br><span class="line">    re=$(echo &quot;$a+$re&quot; | bc)</span><br><span class="line">done</span><br><span class="line">re=$(echo &quot;scale=5;$re/$div&quot; | bc)</span><br><span class="line">echo $re</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>循环次数</th>
<th>EBX时间&#x2F;EAX时间（EAX先执行）</th>
<th>EBX时间&#x2F;EAX时间（EBX先执行）</th>
<th>平均</th>
</tr>
</thead>
<tbody><tr>
<td>10^4</td>
<td>0.98396</td>
<td>1.07485</td>
<td>1.029405</td>
</tr>
<tr>
<td>10^5</td>
<td>0.99509</td>
<td>1.01436</td>
<td>1.004725</td>
</tr>
<tr>
<td>10^6</td>
<td>0.99185</td>
<td>1.01492</td>
<td>1.003385</td>
</tr>
<tr>
<td>10^7</td>
<td><strong>1.00085</strong></td>
<td>1.00216</td>
<td>1.001505</td>
</tr>
<tr>
<td>10^8</td>
<td>0.99907</td>
<td>1.00442</td>
<td>1.001745</td>
</tr>
</tbody></table>
<p>​	怪异的是，在隔一段时间再去测试时，在测试重复次数较小时，结果情况又颠倒，eax先运行则eax慢于ebx，反之则快于ebx。具体情况如上表所示，由于重复次数过大会导致测试时间过长，而过小则很不精确，故此处选择10^4~10^8四个阶段进行测试。值得注意的是10^7时，结果显示均大于1，但是10^8时又不一样，则并不是随着循环次数增大而产生提速效果，显然这样的测试结果并不能十分清晰地说明问题。</p>
<h3 id="2-测试前后不一致的分析与改进"><a href="#2-测试前后不一致的分析与改进" class="headerlink" title="2. 测试前后不一致的分析与改进"></a>2. 测试前后不一致的分析与改进</h3><p>​	此前在数据结构与算法等课程上，对不同数据结构的性能测试上，我也普遍采用了这样一种软件层面的计时方法，那么此处的前后不一致让我着实摸不着头脑。</p>
<p>​	对这种情况，我猜想：</p>
<ol>
<li>可能是因为调用的clock函数计时并不精准，或者在使用clock函数时，其中一些指令与eax&#x2F;ebx的测试代码在流水线中运行存在依赖&#x2F;冲突；</li>
<li>可能是因为同时进行测试，导致部分寄存器的情况在进入eax循环和进入ebx循环中时存在区别，且也可能存在指令依赖，但是分开测试又会存在不同时运行，CPU的状态可能差别较大的问题。</li>
</ol>
<p>​	仅仅推测不能解决问题，故下面对这两个猜想进行逐一的分析和验证。</p>
<h4 id="2-1-替换测试时间方法"><a href="#2-1-替换测试时间方法" class="headerlink" title="2.1 替换测试时间方法"></a>2.1 替换测试时间方法</h4><p>​	仔细查看了反汇编代码，在main函数中clock()函数调用实际是执行了<code>callq  1060 &lt;clock@plt&gt;</code>这一条指令，也就是调用<code>&lt;clock@plt&gt;</code>中的函数，其对应的代码如下。</p>
<img src="image-20221027212618565.png" alt="image-20221027212618565" style="zoom: 25%;" />

<p>​	其中执行了<code>bnd jmpq *0x2f5d</code>，而这一指令似乎是一个系统调用，对于反汇编得到的代码来说，不能找到对应的代码。故尝试用gdb确认这一步具体的操作。</p>
<img src="image-20221027215405682.png" alt="image-20221027215405682" style="zoom: 25%;" />

<p>​	但是发现进入到这一条指令，就显示<code>sysdeps...</code>等，推测是进入了clock.c进行执行，那么继续从clock.c中探究似乎并没有意义，因为通过修改clock.c的代码来改善这一情况并不现实；而对于原有测试指令，也并不能再进一步精简。</p>
<p>​	对此，我在网上查资料的过程中，看到很多资料也指出使用软件方式计时可能会有较大的误差，并不精确。那么在对于指令速度的测试上，可能更适合用硬件层面的指令来完成。</p>
<p>​	要获取运行时间，在汇编中还有许多方法。其中一种是直接使用int 0x80调用time.c，进行系统调用，那么似乎与前面的clock()方法调用clock.c没有区别。而在查阅资料过程中，我发现在intel汇编指令中，指令<code>rdtsc</code>也可以用于获得CPU从上电开始总共经历的时钟周期数，它是隐含操作数指令，会将周期数高32位存在edx寄存器，低32位存在eax寄存器。</p>
<p>​	则两次使用该指令，并通过两处相减即可获取测试代码运行的时钟周期数，也就相应地可以求出运行时间，从而更准确地比较指令运行速度。但是进一步深入学习过程中，我发现由于CPU乱序执行的影响，要保证这一刻流水线已排空，即<code>rdtsc</code>要测量的指令已执行完，才能获取准确结果。所以<code>rdtsc</code>指令需要配合<code>cpuid</code>或<code>lfence</code>指令才能精确获取时间，而intel也提供了<code>rdtscp</code>指令（rdtsc+cpuid)。因此将clock()替换为如下函数进行测试。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;linux/types.h&gt;</span></span></span><br><span class="line">__u64 <span class="title function_">rdtsc</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">        __u32 lo,hi;</span><br><span class="line"></span><br><span class="line">        __asm__ __volatile__</span><br><span class="line">        (</span><br><span class="line">         <span class="string">&quot;rdtscp&quot;</span>:<span class="string">&quot;=a&quot;</span>(lo),<span class="string">&quot;=d&quot;</span>(hi)</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">return</span> (__u64)hi&lt;&lt;<span class="number">32</span>|lo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>循环次数</th>
<th>EBX时间&#x2F;EAX时间（EAX先执行）</th>
<th>EBX时间&#x2F;EAX时间（EBX先执行）</th>
<th>平均</th>
</tr>
</thead>
<tbody><tr>
<td>10^5</td>
<td>0.99622</td>
<td>1.23607</td>
<td>1.116145</td>
</tr>
<tr>
<td>10^6</td>
<td>1.00488</td>
<td>1.00189</td>
<td>1.003385</td>
</tr>
<tr>
<td>10^7</td>
<td>1.00311</td>
<td>0.99799</td>
<td>1.00055</td>
</tr>
<tr>
<td>10^8</td>
<td>1.00011</td>
<td>0.99999</td>
<td>1.00005</td>
</tr>
</tbody></table>
<p>部分结构截图如下。（其中test_rdtsc为b先于a，test_r为a先于b）</p>
<p>10^5:</p>
<img src="image-20221029200156014.png" alt="image-20221029200156014" style="zoom:33%;" />

<p>10^6:</p>
<img src="image-20221029172631808.png" alt="image-20221029172631808" style="zoom:33%;" />

<p>10^7:</p>
<img src="image-20221029174444013.png" alt="image-20221029174444013" style="zoom:33%;" />

<p>10^8:</p>
<img src="image-20221029200307977.png" alt="image-20221029200307977" style="zoom:33%;" />

<p>​	相对来说，使用rdtsc指令测试结果上来说也不尽人意，随机性依然较强，每次得到的时间比都不同。分析原因，因为代码以及反汇编除了测试的add指令并无不同，可能依然是由于不同顺序执行下存在指令的依赖，导致流水线上的乱序执行和并发时存在一些需要stall的地方，从而使得整体上的表现会因为顺序而不同；同时CPU的状态变化可能也会导致一些随机性。但是回过头综合看两个顺序的指令执行效果，不论是使用time.h库还是rdtsc指令，在不同循环次数下，不同顺序的比例取平均值，在总体上还是有所提升的（按照结果大约提升0.1%~1%，实际情况下更复杂，可能会更低，不过这样的提升也相对可观）。</p>
<h4 id="2-2-单独测试EAX-x2F-EBX"><a href="#2-2-单独测试EAX-x2F-EBX" class="headerlink" title="2.2 单独测试EAX&#x2F;EBX"></a>2.2 单独测试EAX&#x2F;EBX</h4><p>​	对于第二个想法，即可能由于顺序执行时每个指令测试时寄存器状况不同的情况，我修改了部分的代码（使其输出各自测试的时间长度），并使用前面的shell脚本进行计算，即可得到两个寄存器测试的运行时间。</p>
<table>
<thead>
<tr>
<th>循环次数</th>
<th>EAX(ms)</th>
<th>EBX(ms)</th>
</tr>
</thead>
<tbody><tr>
<td>10^6</td>
<td>1.5227</td>
<td>1.6671</td>
</tr>
<tr>
<td>10^7</td>
<td>15.239</td>
<td>15.334</td>
</tr>
<tr>
<td>10^8</td>
<td>152.94</td>
<td>154.38</td>
</tr>
<tr>
<td>10^9</td>
<td>1536.7</td>
<td>1537.5</td>
</tr>
</tbody></table>
<p>部分测试图片（由1中修改而来，命名问题，test_EAX实际测了EBX，test_EBX实际测了EAX）</p>
<p>10^6:</p>
<img src="image-20221029210753405.png" alt="image-20221029210753405" style="zoom:33%;" />

<p>10^7:</p>
<img src="image-20221029210728451.png" alt="image-20221029210728451" style="zoom:31%;" />

<p>10^8:</p>
<img src="image-20221029210613654.png" alt="image-20221029210613654" style="zoom:33%;" />

<p>10^9:</p>
<img src="image-20221029210125546.png" alt="image-20221029210125546" style="zoom:33%;" />

<p>​	由此结果可以看到，程序时间随循环次数增长呈近似线性的增长，EAX平均时间短于EBX。这也从另一方面证实了我们最开始提出的假设，即对于ADD指令，确实使用eax寄存器能相对更快。</p>
<h3 id="3-x86汇编程序直接测试"><a href="#3-x86汇编程序直接测试" class="headerlink" title="3. x86汇编程序直接测试"></a>3. x86汇编程序直接测试</h3><p>​	鉴于上述都是基于C语言的操作，依然可能会有较多无关指令无法彻底排除。而有了前面的基础，直接使用汇编代码进行测试也就相对易于实现了（虽然由于没有x86汇编的基础，在起步时依然比较困难，每一步都不太熟悉）。依据老师上课讲的指令以及一些网络资料，我尝试着编写了这样一段程序（部分重复代码详见附件）。主要功能上是实现一个<code>add eax， 0xffff7040</code>的循环，并用rdtscp进行记录并输出。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">; test.asm </span><br><span class="line">section .data              ; 数据段声明</span><br><span class="line">        msg db &quot;&quot;, 0xA     ; 要输出的字符串</span><br><span class="line">        len equ $ - msg                 ; 字串长度</span><br><span class="line">		a dq 1</span><br><span class="line">		b dq 1</span><br><span class="line">		ta dq 1</span><br><span class="line">		td dq 1</span><br><span class="line">section .bss</span><br><span class="line">    	num    resd 1</span><br><span class="line">    	buffer resb 10</span><br><span class="line">section .text            ; 代码段声明</span><br><span class="line">global _start            ; 指定入口函数</span><br><span class="line">_start:                  ; 在屏幕上显示一个字符串</span><br><span class="line">;eax test</span><br><span class="line">		rdtscp</span><br><span class="line">		mov qword[ta], rax</span><br><span class="line">		mov qword[td], rdx</span><br><span class="line">		</span><br><span class="line">		;this is the loop for add</span><br><span class="line">		xor edx, edx</span><br><span class="line">		xor eax, eax</span><br><span class="line">loop_1:	inc edx</span><br><span class="line">		add eax, 0xffff7040</span><br><span class="line">		cmp edx, 0xfffff</span><br><span class="line">		jbe loop_1</span><br><span class="line">		rdtscp</span><br><span class="line">		shl rdx, 0x20</span><br><span class="line">		mov rcx, rax</span><br><span class="line">		add rcx, rdx</span><br><span class="line">		mov rax, [ta]</span><br><span class="line">		mov rdx, [td]</span><br><span class="line">		shl rdx, 0x20</span><br><span class="line">		add rdx, rax</span><br><span class="line">		sub rcx, rdx</span><br><span class="line">enda:	</span><br><span class="line">		mov eax, ecx</span><br><span class="line">		mov esi, buffer</span><br><span class="line">		call int_to_string</span><br><span class="line"></span><br><span class="line">		mov edx, ecx     ; 参数三：字符串长度</span><br><span class="line">        mov ecx, eax     ; 参数二：要显示的字符串</span><br><span class="line">        mov ebx, 1       ; 参数一：文件描述符(stdout) </span><br><span class="line">        mov eax, 4       ; 系统调用号(sys_write) </span><br><span class="line">        int 0x80         ; 调用内核功能</span><br><span class="line"></span><br><span class="line">		mov edx, len     ; 参数三：字符串长度</span><br><span class="line">        mov ecx, msg     ; 参数二：要显示的字符串</span><br><span class="line">        mov ebx, 1       ; 参数一：文件描述符(stdout) </span><br><span class="line">        mov eax, 4       ; 系统调用号(sys_write) </span><br><span class="line">        int 0x80         ; 调用内核功能</span><br><span class="line"></span><br><span class="line">		nop ;此处省略了多个nop，用于让流水线完成</span><br><span class="line">		;...用于测试ebx，与前面eax一样</span><br><span class="line"></span><br><span class="line">; Input:</span><br><span class="line">; eax = integer value to convert</span><br><span class="line">; esi = pointer to buffer to store the string in (must have room for at least 10 bytes)</span><br><span class="line">; Output:</span><br><span class="line">; eax = pointer to the first character of the generated string</span><br><span class="line">; ecx = length of the generated string</span><br><span class="line">int_to_string:</span><br><span class="line">	;来自 https://www.codingdict.com/questions/45480</span><br><span class="line">	;此处省略过程，仅仅用于将int转化为字符串</span><br></pre></td></tr></table></figure>

<p>​	使用nasm编译，并采用ld链接，可以成功运行，运行结果如下。</p>
<img src="image-20221029212543267.png" alt="image-20221029212543267" style="zoom: 50%;" />

<p>​	下面是将两端测试单独分开执行的结果。由于单独执行时，使用脚本出现了输出处理的问题（因为程序中调用系统调用时是按照输出字符串格式输出，由于个人汇编能力限制，没办法直接输出int，而这个格式在shell处理时就无法读入），所以此处给出了手动运行的代码。</p>
<img src="image-20221029214152011.png" alt="image-20221029214152011" style="zoom: 50%;" />

<p>​	总体上也是EAX快于EBX，虽然偶尔会出现较怪异的情况，猜测是使用rdtsc指令时，寄存器值存在溢出，或者产生了其他中断&#x2F;stall，但不影响整体的情况。</p>
<h3 id="4-进一步分析编码因素"><a href="#4-进一步分析编码因素" class="headerlink" title="4. 进一步分析编码因素"></a>4. 进一步分析编码因素</h3><p>​	基于上面的测试，可以看到对于加法这类指令，确实使用EAX会快于EBX等其他寄存器。对于这一情况，我们的解释是由于编码的问题，使用eax的指令编码将比使用其他寄存器短一字节，这一点可以在c语言转汇编时清晰地看到，<code>add eax, 0xffff7040</code>的编码是<code>05 40 70 ff</code>，而<code>add ebx, 0xffff7040</code>的编码则是<code>81 c3 40 70 ff</code>。</p>
<img src="image-20221027201332084.png" alt="image-20221027201332084" style="zoom:33%;" />

<img src="image-20221027201313076.png" alt="image-20221027201313076" style="zoom:33%;" />

<p>​	那么很自然地想到，如果我们人为将eax的编码加一字节，程序的运行结果又会如何？联系到老师上课讲的对于x86指令的格式，可以通过加前缀的方式来扩展指令，从而指定一些指令的具体使用情况。而许多指令在实际编码时也会加66前缀来实现对齐。</p>
<img src="image-20221029215825261.png" alt="image-20221029215825261" style="zoom: 33%;" />

<p>​	尝试使用在操作数前加66H，因为66H用于改变操作数size，那对于64位模式下，改为32位，加上66H不会产生影响。而要增加前缀，首先也需要一个空位进行修改，否则会出现修改后使得前面指令出现异常的情况，而这一个空白位，结果试验，可以由nop指令来提供，故改1中测试代码的内联汇编为如下。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">asm</span>(</span><br><span class="line">        <span class="string">&quot;nop\n&quot;</span></span><br><span class="line">        <span class="string">&quot;add $0xffff7040,%%eax&quot;</span></span><br><span class="line">        : :</span><br><span class="line">        : </span><br><span class="line">	);</span><br></pre></td></tr></table></figure>

<p>​	经过反汇编，可以看到结果上确实能够多出一字节。</p>
<img src="image-20221029221528937.png" alt="image-20221029221528937" style="zoom:33%;" />

<p>​	那么相应地，我们可以修改其可执行文件中的编码，来实现指令编码的延长。</p>
<img src="image-20221030002951218.png" alt="image-20221030002951218" style="zoom:33%;" />

<p>​	在修改之前，我先在Online-Assembler-and-Disassembler中测试了是否可以翻译，发现编码<code>66054070ffff</code>对应的指令是<code>add ax, 0x7040</code>，显然与原指令不同，对此我仔细对照了操作数前缀的格式表，发现对于前缀66，只能用于64位模式下转为16位（那也就是前面转化成ax的原因），那么补充66H显然会造成显著的指令意义上的区别，故寻求其他填充前缀。</p>
<img src="image-20221029221404819.png" alt="image-20221029221404819" style="zoom: 33%;" />

<p>​	印象中上课讲66H前缀时，也讲到寻址模式相关的前缀67H，是用于64位下设置寻址模式为32位。而对于这条add指令，显然不涉及寻址，仅仅只需做寄存器值和立即数的加法，那么，我们加上这样的前缀，似乎不会影响整条指令的功能。同样，我们先用工具Online-Assembler-and-Disassembler翻译，得到结果如下图。</p>
<img src="image-20221030004403672.png" alt="image-20221030004403672" style="zoom: 33%;" />

<p>​	可以看到，这样的前缀并不影响指令内涵，同样的，我们修改预留好的nop位为67H。根据054070对应的ASCII码，找到对应的指令，并进行修改。</p>
<img src="image-20221030004922599.png" alt="image-20221030004922599" style="zoom:33%;" />

<p>​	修改为67H，这样既不影响前面指令，也实现了延长指令编码的功能。</p>
<img src="image-20221030004940256.png" alt="image-20221030004940256" style="zoom: 33%;" />

<p>​	使用objdump工具获取对应的汇编指令，查看指令是否出现更改。</p>
<img src="image-20221030005340975.png" alt="image-20221030005340975" style="zoom: 33%;" />

<p>​	可以发现在AT&amp;T格式下，指令显示了addr32前缀，这并不影响其基本功能。但是为了确保其功能确实并没有改变，还是使用gdb调试，检验操作后的寄存器值，以进一步证实这一猜想。</p>
<img src="image-20221030005937822.png" alt="image-20221030005937822" style="zoom: 25%;" />

<img src="image-20221030010016841.png" alt="image-20221030010016841" style="zoom:25%;" />

<p>​	执行前后，rax寄存器值由0xca0到0xffff7ce0，确实是加了0xffff7040，也就说明指令功能确实没有变化。我们相应的进行与1-3步中的测试，就可以检验编码是否确实是影响这条指令运行速度的因素。我们修改shell以支持顺序进行测试。对此我们运行了5次整体测试程序（电脑静音模式）和5次电脑增强模式下的测试。</p>
<img src="image-20221030141558674.png" alt="image-20221030141558674" style="zoom: 33%;" />

<img src="image-20221030141824120.png" alt="image-20221030141824120" style="zoom:33%;" />

<img src="image-20221030142908030.png" alt="image-20221030142908030" style="zoom: 33%;" />

<img src="image-20221030144125474.png" alt="image-20221030144125474" style="zoom:33%;" />

<img src="image-20221031132940456.png" alt="image-20221031132940456" style="zoom: 28%;" />

<img src="image-20221031133048763.png" alt="image-20221031133048763" style="zoom: 28%;" />

<p>​	整体上看，额外编码后的add指令在运行时间上有所延长，但是多数情况下，eax+op的执行时间短于ebx指令的执行时间。这也说明，指令编码长短的因素确实会影响指令执行的速度，但是具体的影响因素从实验结果中却较难分析，因为我们此处的测试不可能保证三个测试循环同时运行，则不同时间的CPU状态并不相同，且这仅仅是我个人电脑的运行结果，可能在其他具有不同硬件情况的平台上运行的结果又不相同；同时，即使保证了同时运行（尝试过采用多线程进行测试），每一个线程都可能有不同的资源分配情况，则也无法完全找到情况相同的运行环境，所以我推测这也是很多时候测试结果产生波动和随机性分布的原因，但这一点上我如今依然没有找到最合适的解决方案，希望在未来的学习和研究中能够继续深入。</p>
<hr>
<h2 id="三、效果分析"><a href="#三、效果分析" class="headerlink" title="三、效果分析"></a>三、效果分析</h2><p>​	详细的数据见二中的分析。整体的结果呈现上，A系列寄存器（以EAX为例）在加法ADD指令上的表现优于B系列寄存器的表现，且编码长度因素在这个方面存在一定的影响。同理，对于C等其他系列寄存器的表现上，也可以以此类推，但是由于并没有实际进行测试，所以尚不能下断言；同样地，对于sub等其他算数指令的效果，也只能以add为例进行类推，推测应当有类似的结果，但是也仍然需要进一步测试确定。</p>
<h2 id="四、实验体会"><a href="#四、实验体会" class="headerlink" title="四、实验体会"></a>四、实验体会</h2><p>​	最开始进行探索时，我感觉选择这样一条十分基础的指令，从这样一个小的方面切入，会不会过于简单，没有什么内容，其实心里也是比较忐忑的。但是在探索过程中，实际花费的时间和遇到的困难远远超过了我的预期，原来一条十分基本的指令深入下去，也能有许多意想不到的收获。比如最开始性能验证时，结果随机性较大，并没有很明显的一边倒（即eax快于ebx），这一度也让我十分困扰。为了实事求是，前面结果的不尽人意也敦促我继续提出猜想，并额外采取了其他方式进行进一步验证，而这一环节过程中也产生了一系列问题，这些问题也促使我继续探索，继续思考，不断深入。</p>
<p>​	因为结果上仍然有不确定和偶然因素存在，整个测试过程也可能因为实验平台的区别而存在不一样的可能，我无法100%下断言我得出的结论是正确的、符合实际情况的。虽然如此，在整体的探索过程当中，我也有机会对此前课程上数据结构性能测试准确性一直存在的疑问进行了更细致地探讨和分析，也用到了许多不同课程中学到的知识，进行综合地使用和贯通；同时也在写汇编代码过程中，进一步理解了老师上课讲到的许多指令的用法，虽然之前没有基础，但是通过这次实验的动手实践，我也能够初步编写基本的程序。这些都是这次探索中我感觉到最有价值的事。虽然花费了很多时间，但是我也收获了很多，让我真正有机会跳开很多课程繁忙密集的实验安排，去反思过去遇到的一直没有时间去细想的问题。</p>
<h2 id="五、经验教训"><a href="#五、经验教训" class="headerlink" title="五、经验教训"></a>五、经验教训</h2><ol>
<li><p>最开始编写测试时间程序时，因为想测试同一条指令，担心每次add导致eax寄存器的值可能会溢出，故在循环内，将eax&#x2F;ebx绑定的变量a&#x2F;b赋值为0，这样似乎能保证每次都是0+0xffff7040，但是后来发现，这样反汇编结果中有mov $0x0,%eax&#x2F;ebx这一条，虽然编码长度一致，但是有可能影响到整体的测试。在实际测试过程中，也确实发现，当我把eax和ebx测试的顺序颠倒后，结果上却也正好相反，且相差甚大，故最后删除了这两条赋值语句，继续进行测试。</p>
<img src="image-20221027201332084.png" alt="image-20221027201332084" style="zoom:33%;" />

<img src="image-20221027201313076.png" alt="image-20221027201313076" style="zoom:33%;" />
</li>
<li><p>最开始将两个指令的测试放在一个程序中，我比较疑惑是否会在前后产生指令上的依赖，因此我尝试了将两个测试放在两个线程中运行，虽然确实将两端测试分开了，但是创建线程之后具体指令执行的资源分配情况仍然难以确切地知道，所以最后放弃了这一测试方法。</p>
<img src="image-20221031141707762.png" alt="image-20221031141707762" style="zoom:30%;" />
</li>
<li><p>在使用rdtscp指令测试时间时，因为该指令会将得到的硬件时钟数放在两个寄存器中，我先直接尝试了在该指令后，对rdx左移32位，再加上rax，这样就获得了准确的时钟周期。但是这样在测试上，又额外加入了这几条指令的时钟周期，且在流水线中执行时，可能会产生冲突&#x2F;stall等情况，从而影响测试的准确性（实际测试如图，造成了不确定的结果，得不到任何结论，甚至可能ebx更快），但是这两个寄存器的值必须得保存下来，不然在循环中，包括第二次调用rdtscp指令时，他们都会被修改。故最后只好采用先将两个寄存器暂存在data段定义的变量中，以尽可能减少误差。</p>
<img src="image-20221029151134159.png" alt="image-20221029151134159" style="zoom:50%;" /></li>
</ol>
<h2 id="六、参考文献"><a href="#六、参考文献" class="headerlink" title="六、参考文献"></a>六、参考文献</h2><p>1.<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/242702373">测量CPU的利器 - TSC (Time Stamp Counter) - 知乎 (zhihu.com)</a></p>
<p>2.<a target="_blank" rel="noopener" href="https://www.codingdict.com/questions/45480">使用x86 32位Linux sys_write（NASM）打印整数 (codingdict.com)</a></p>
<p>3.<a target="_blank" rel="noopener" href="https://blog.csdn.net/xfcyhuang/article/details/6230021">X86指令内幕 ——深入了解Prefix_xfcyhuang的博客-CSDN博客_prefix汇编</a></p>
<p>4.<a target="_blank" rel="noopener" href="https://shell-storm.org/online/Online-Assembler-and-Disassembler">https://shell-storm.org/online/Online-Assembler-and-Disassembler</a></p>
<p>5.<a target="_blank" rel="noopener" href="https://www.intel.com/content/www/us/en/developer/articles/technical/intel-sdm.html">Intel® 64 and IA-32 Architectures Software Developer Manuals</a></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://tony-yzj.cn">也无风雨</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://tony-yzj.cn/2022/10/31/%E6%8C%87%E4%BB%A4%E6%8E%A2%E7%B4%A2/">http://tony-yzj.cn/2022/10/31/%E6%8C%87%E4%BB%A4%E6%8E%A2%E7%B4%A2/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://tony-yzj.cn" target="_blank">Tech, Poem & More</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/ASM/">ASM</a></div><div class="post_share"><div class="social-share" data-image="https://s2.loli.net/2023/02/02/LI1QZmy5l2TqzeY.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/12/28/%E6%9C%80%E5%A4%A7%E5%AD%90%E7%9F%A9%E9%98%B5%E5%92%8C%E9%97%AE%E9%A2%98%E7%9A%84%E5%90%91%E9%87%8F%E5%8C%96%E5%8A%A0%E9%80%9F%E6%8E%A2%E7%A9%B6%E4%B8%8E%E6%89%A9%E5%B1%95/"><img class="prev-cover" src="https://s2.loli.net/2023/02/02/LI1QZmy5l2TqzeY.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">向量化加速:尝试基于SIMD加速最大子矩阵和问题</div></div></a></div><div class="next-post pull-right"><a href="/2022/10/03/poem_2/"><img class="next-cover" src="https://s2.loli.net/2022/10/03/xOmwMAjdS2gpTcR.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">七律·忽觉秋凉</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/12/28/%E6%9C%80%E5%A4%A7%E5%AD%90%E7%9F%A9%E9%98%B5%E5%92%8C%E9%97%AE%E9%A2%98%E7%9A%84%E5%90%91%E9%87%8F%E5%8C%96%E5%8A%A0%E9%80%9F%E6%8E%A2%E7%A9%B6%E4%B8%8E%E6%89%A9%E5%B1%95/" title="向量化加速:尝试基于SIMD加速最大子矩阵和问题"><img class="cover" src="https://s2.loli.net/2023/02/02/LI1QZmy5l2TqzeY.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-12-28</div><div class="title">向量化加速:尝试基于SIMD加速最大子矩阵和问题</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div><div id="comment-switch"><span class="first-comment">Valine</span><span class="switch-btn"></span><span class="second-comment">Disqus</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div><div><div id="disqus_thread"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://s2.loli.net/2022/10/01/I2nSFvzp48lecKO.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">也无风雨</div><div class="author-info__description">归去，也无风雨也无晴。</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">6</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">3</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Tony-yzj"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Tony-yzj" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:3200103894@zju.edu.cn" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">这里是也无风雨的Blog，欢迎欢迎！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#x86%E6%9E%B6%E6%9E%84%E4%B8%8BA%E7%B3%BB%E5%88%97%E5%AF%84%E5%AD%98%E5%99%A8%E7%AE%97%E6%95%B0%E6%93%8D%E4%BD%9C%EF%BC%88%E4%BB%A5ADD%E6%8C%87%E4%BB%A4%E4%B8%BA%E4%BE%8B%EF%BC%89%E7%9A%84%E6%8F%90%E9%80%9F%E6%83%85%E5%86%B5%E6%8E%A2%E7%B4%A2"><span class="toc-text">x86架构下A系列寄存器算数操作（以ADD指令为例）的提速情况探索</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E6%8E%A2%E7%B4%A2%E8%83%8C%E6%99%AF"><span class="toc-text">一、探索背景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E6%8E%A2%E7%B4%A2%E8%BF%87%E7%A8%8B"><span class="toc-text">二、探索过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%9F%BA%E4%BA%8Etime-h%E7%9A%84%E7%AE%80%E6%98%93%E6%B5%8B%E8%AF%95%E7%A8%8B%E5%BA%8F"><span class="toc-text">1. 基于time.h的简易测试程序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%B5%8B%E8%AF%95%E5%89%8D%E5%90%8E%E4%B8%8D%E4%B8%80%E8%87%B4%E7%9A%84%E5%88%86%E6%9E%90%E4%B8%8E%E6%94%B9%E8%BF%9B"><span class="toc-text">2. 测试前后不一致的分析与改进</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-%E6%9B%BF%E6%8D%A2%E6%B5%8B%E8%AF%95%E6%97%B6%E9%97%B4%E6%96%B9%E6%B3%95"><span class="toc-text">2.1 替换测试时间方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-%E5%8D%95%E7%8B%AC%E6%B5%8B%E8%AF%95EAX-x2F-EBX"><span class="toc-text">2.2 单独测试EAX&#x2F;EBX</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-x86%E6%B1%87%E7%BC%96%E7%A8%8B%E5%BA%8F%E7%9B%B4%E6%8E%A5%E6%B5%8B%E8%AF%95"><span class="toc-text">3. x86汇编程序直接测试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E8%BF%9B%E4%B8%80%E6%AD%A5%E5%88%86%E6%9E%90%E7%BC%96%E7%A0%81%E5%9B%A0%E7%B4%A0"><span class="toc-text">4. 进一步分析编码因素</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E6%95%88%E6%9E%9C%E5%88%86%E6%9E%90"><span class="toc-text">三、效果分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E5%AE%9E%E9%AA%8C%E4%BD%93%E4%BC%9A"><span class="toc-text">四、实验体会</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E7%BB%8F%E9%AA%8C%E6%95%99%E8%AE%AD"><span class="toc-text">五、经验教训</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE"><span class="toc-text">六、参考文献</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/12/28/%E6%9C%80%E5%A4%A7%E5%AD%90%E7%9F%A9%E9%98%B5%E5%92%8C%E9%97%AE%E9%A2%98%E7%9A%84%E5%90%91%E9%87%8F%E5%8C%96%E5%8A%A0%E9%80%9F%E6%8E%A2%E7%A9%B6%E4%B8%8E%E6%89%A9%E5%B1%95/" title="向量化加速:尝试基于SIMD加速最大子矩阵和问题"><img src="https://s2.loli.net/2023/02/02/LI1QZmy5l2TqzeY.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="向量化加速:尝试基于SIMD加速最大子矩阵和问题"/></a><div class="content"><a class="title" href="/2022/12/28/%E6%9C%80%E5%A4%A7%E5%AD%90%E7%9F%A9%E9%98%B5%E5%92%8C%E9%97%AE%E9%A2%98%E7%9A%84%E5%90%91%E9%87%8F%E5%8C%96%E5%8A%A0%E9%80%9F%E6%8E%A2%E7%A9%B6%E4%B8%8E%E6%89%A9%E5%B1%95/" title="向量化加速:尝试基于SIMD加速最大子矩阵和问题">向量化加速:尝试基于SIMD加速最大子矩阵和问题</a><time datetime="2022-12-28T11:38:00.000Z" title="发表于 2022-12-28 19:38:00">2022-12-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/10/31/%E6%8C%87%E4%BB%A4%E6%8E%A2%E7%B4%A2/" title="指令探索"><img src="https://s2.loli.net/2023/02/02/LI1QZmy5l2TqzeY.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="指令探索"/></a><div class="content"><a class="title" href="/2022/10/31/%E6%8C%87%E4%BB%A4%E6%8E%A2%E7%B4%A2/" title="指令探索">指令探索</a><time datetime="2022-10-31T09:05:00.000Z" title="发表于 2022-10-31 17:05:00">2022-10-31</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/10/03/poem_2/" title="七律·忽觉秋凉"><img src="https://s2.loli.net/2022/10/03/xOmwMAjdS2gpTcR.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="七律·忽觉秋凉"/></a><div class="content"><a class="title" href="/2022/10/03/poem_2/" title="七律·忽觉秋凉">七律·忽觉秋凉</a><time datetime="2022-10-03T02:08:00.000Z" title="发表于 2022-10-03 10:08:00">2022-10-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/10/02/collection_1/" title="行军集"><img src="https://s2.loli.net/2022/10/02/WiuUPlCRkmyJaV4.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="行军集"/></a><div class="content"><a class="title" href="/2022/10/02/collection_1/" title="行军集">行军集</a><time datetime="2022-10-02T04:19:00.000Z" title="发表于 2022-10-02 12:19:00">2022-10-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/10/01/poem_1/" title="无题：记《隐入尘烟》"><img src="https://s2.loli.net/2022/10/01/DL9xtAqoXlWIESp.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无题：记《隐入尘烟》"/></a><div class="content"><a class="title" href="/2022/10/01/poem_1/" title="无题：记《隐入尘烟》">无题：记《隐入尘烟》</a><time datetime="2022-10-01T11:09:00.000Z" title="发表于 2022-10-01 19:09:00">2022-10-01</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2023 By 也无风雨</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Share everything with U <a href="http://tony-yzj.cn/">here</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: '',
      appKey: '',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !false) {
  if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script><script>function loadDisqus () {
  var disqus_config = function () {
    this.page.url = 'http://tony-yzj.cn/2022/10/31/%E6%8C%87%E4%BB%A4%E6%8E%A2%E7%B4%A2/'
    this.page.identifier = '/2022/10/31/%E6%8C%87%E4%BB%A4%E6%8E%A2%E7%B4%A2/'
    this.page.title = '指令探索'
  };

  window.disqusReset = () => {
    DISQUS.reset({
      reload: true,
      config: disqus_config
    })
  }

  if (window.DISQUS) disqusReset()
  else {
    (function() { 
      var d = document, s = d.createElement('script');
      s.src = 'https://.disqus.com/embed.js';
      s.setAttribute('data-timestamp', +new Date());
      (d.head || d.body).appendChild(s);
    })();
  }

  document.getElementById('darkmode').addEventListener('click', () => {
    setTimeout(() => window.disqusReset(), 200)
  })
}

if ('Valine' === 'Disqus' || !false) {
  if (false) btf.loadComment(document.getElementById('disqus_thread'), loadDisqus)
  else loadDisqus()
} else {
  function loadOtherComment () {
    loadDisqus()
  }
}
</script></div><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="false" data-text="少年侠气,交结五都雄,肝胆洞,毛发耸,立谈中,死生同,一诺千金重,推翘勇,矜豪纵,轻盖拥,联飞鞚,斗城东,轰饮酒垆,春色浮寒瓮,吸海垂虹,闲呼鹰嗾犬,白羽摘雕弓,狡穴俄空,乐匆匆" data-fontsize="20px" data-random="false" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"model":{"jsonPath":"/live2dw/assets/hijiki.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body></html>